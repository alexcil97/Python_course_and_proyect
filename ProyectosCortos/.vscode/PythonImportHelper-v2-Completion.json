[
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "obtener_entero",
        "kind": 2,
        "importPath": "Contador",
        "description": "Contador",
        "peekOfCode": "def obtener_entero(mensaje):\n    \"\"\"Solicita un n√∫mero entero y maneja errores de entrada.\"\"\"\n    while True:\n        try:\n            return int(input(mensaje))\n        except ValueError:\n            print(\"‚ùå Entrada inv√°lida. Debes ingresar un n√∫mero entero.\")\ndef seleccionar_categoria():\n    \"\"\"Muestra las categor√≠as y permite seleccionar una.\"\"\"\n    print(\"\\nüìÇ Categor√≠as disponibles:\")",
        "detail": "Contador",
        "documentation": {}
    },
    {
        "label": "seleccionar_categoria",
        "kind": 2,
        "importPath": "Contador",
        "description": "Contador",
        "peekOfCode": "def seleccionar_categoria():\n    \"\"\"Muestra las categor√≠as y permite seleccionar una.\"\"\"\n    print(\"\\nüìÇ Categor√≠as disponibles:\")\n    for i, cat in enumerate(t1.keys(), 1):\n        print(f\"{i}. {cat}\")\n    while True:\n        seleccion = obtener_entero(\"\\nElige el n√∫mero de la categor√≠a: \") - 1\n        if 0 <= seleccion < len(t1):\n            return list(t1.keys())[seleccion]\n        print(\"‚ùå Opci√≥n inv√°lida. Int√©ntalo de nuevo.\")",
        "detail": "Contador",
        "documentation": {}
    },
    {
        "label": "mostrar_datos",
        "kind": 2,
        "importPath": "Contador",
        "description": "Contador",
        "peekOfCode": "def mostrar_datos():\n    \"\"\"Muestra el diccionario estructurado de forma m√°s legible manteniendo el orden.\"\"\"\n    print(\"\\nüìä **Datos actuales:**\")\n    datos_mostrados = False\n    for categoria, tecnologias in t1.items():\n        if tecnologias:  # Solo muestra categor√≠as con datos\n            print(f\"\\nüîπ {categoria}:\")\n            for tecnologia, cantidad in tecnologias.items():\n                print(f\"   - {tecnologia.capitalize()}: {cantidad}\")\n            datos_mostrados = True",
        "detail": "Contador",
        "documentation": {}
    },
    {
        "label": "eliminar_tecnologia",
        "kind": 2,
        "importPath": "Contador",
        "description": "Contador",
        "peekOfCode": "def eliminar_tecnologia():\n    \"\"\"Permite eliminar una tecnolog√≠a de una categor√≠a espec√≠fica.\"\"\"\n    if all(not tecnologias for tecnologias in t1.values()):\n        print(\"‚ùå No hay datos para eliminar.\")\n        return\n    print(\"\\nüìÇ **Categor√≠as disponibles:**\")\n    categorias_disponibles = [cat for cat in t1.keys() if t1[cat]]  # Filtra solo las que tienen datos\n    for i, cat in enumerate(categorias_disponibles, 1):\n        print(f\"{i}. {cat}\")\n    cat_index = obtener_entero(\"\\nElige el n√∫mero de la categor√≠a: \") - 1",
        "detail": "Contador",
        "documentation": {}
    },
    {
        "label": "t1",
        "kind": 5,
        "importPath": "Contador",
        "description": "Contador",
        "peekOfCode": "t1 = OrderedDict({categoria: {} for categoria in [\n    \"Control de Versiones\", \"CI/CD\", \"Cloud Computing\", \"Lenguajes de Programaci√≥n\",\n    \"Desarrollo de Interfaces\", \"APIs y Servicios Web\", \"Contenedores\",\n    \"Bases de Datos\", \"Visualizaci√≥n de Datos\", \"Seguridad\", \"Testing\", \"Desarrollo M√≥vil\",\"Big data y procesamiento de datos\"\n]})\n# Diccionario para guardar a qu√© categor√≠a pertenece cada tecnolog√≠a\ntech_to_category = {}\ndef obtener_entero(mensaje):\n    \"\"\"Solicita un n√∫mero entero y maneja errores de entrada.\"\"\"\n    while True:",
        "detail": "Contador",
        "documentation": {}
    },
    {
        "label": "tech_to_category",
        "kind": 5,
        "importPath": "Contador",
        "description": "Contador",
        "peekOfCode": "tech_to_category = {}\ndef obtener_entero(mensaje):\n    \"\"\"Solicita un n√∫mero entero y maneja errores de entrada.\"\"\"\n    while True:\n        try:\n            return int(input(mensaje))\n        except ValueError:\n            print(\"‚ùå Entrada inv√°lida. Debes ingresar un n√∫mero entero.\")\ndef seleccionar_categoria():\n    \"\"\"Muestra las categor√≠as y permite seleccionar una.\"\"\"",
        "detail": "Contador",
        "documentation": {}
    }
]